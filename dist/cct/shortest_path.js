// taken from https://github.com/alainbryden/bitburner-scripts/blob/main/Tasks/contractor.js.solver.js
export function ShortestPath(data) {
    //slightly adapted and simplified to get rid of MinHeap usage, and construct a valid path from potential candidates   
    //MinHeap replaced by simple array acting as queue (breadth first search)  
    const width = data[0].length;
    const height = data.length;
    const dstY = height - 1;
    const dstX = width - 1;
    const distance = new Array(height);
    //const prev: [[number, number] | undefined][] = new Array(height);
    const queue = [];
    for (let y = 0; y < height; y++) {
        distance[y] = new Array(width).fill(Infinity);
        //prev[y] = new Array(width).fill(undefined) as [undefined];
    }
    // @ts-ignore
    function validPosition(y, x) {
        return y >= 0 && y < height && x >= 0 && x < width && data[y][x] == 0;
    }
    // List in-bounds and passable neighbors
    // @ts-ignore
    function* neighbors(y, x) {
        if (validPosition(y - 1, x))
            yield [y - 1, x]; // Up
        if (validPosition(y + 1, x))
            yield [y + 1, x]; // Down
        if (validPosition(y, x - 1))
            yield [y, x - 1]; // Left
        if (validPosition(y, x + 1))
            yield [y, x + 1]; // Right
    }
    // Prepare starting point
    distance[0][0] = 0;
    //## Original version
    // queue.push([0, 0], 0);
    // // Take next-nearest position and expand potential paths from there
    // while (queue.size > 0) {
    //   const [y, x] = queue.pop() as [number, number];
    //   for (const [yN, xN] of neighbors(y, x)) {
    //     const d = distance[y][x] + 1;
    //     if (d < distance[yN][xN]) {
    //       if (distance[yN][xN] == Infinity)
    //         // Not reached previously
    //         queue.push([yN, xN], d);
    //       // Found a shorter path
    //       else queue.changeWeight(([yQ, xQ]) => yQ == yN && xQ == xN, d);
    //       //prev[yN][xN] = [y, x];
    //       distance[yN][xN] = d;
    //     }
    //   }
    // }
    //Simplified version. d < distance[yN][xN] should never happen for BFS if d != infinity, so we skip changeweight and simplify implementation
    //algo always expands shortest path, distance != infinity means a <= lenght path reaches it, only remaining case to solve is infinity    
    queue.push([0, 0]);
    while (queue.length > 0) {
        // @ts-ignore
        const [y, x] = queue.shift();
        for (const [yN, xN] of neighbors(y, x)) {
            if (distance[yN][xN] == Infinity) {
                queue.push([yN, xN]);
                distance[yN][xN] = distance[y][x] + 1;
            }
        }
    }
    // No path at all?
    if (distance[dstY][dstX] == Infinity)
        return "";
    //trace a path back to start
    let path = "";
    let [yC, xC] = [dstY, dstX];
    while (xC != 0 || yC != 0) {
        const dist = distance[yC][xC];
        for (const [yF, xF] of neighbors(yC, xC)) {
            if (distance[yF][xF] == dist - 1) {
                path = (xC == xF ? (yC == yF + 1 ? "D" : "U") : (xC == xF + 1 ? "R" : "L")) + path;
                [yC, xC] = [yF, xF];
                break;
            }
        }
    }
    return path;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hvcnRlc3RfcGF0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jY3Qvc2hvcnRlc3RfcGF0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxzR0FBc0c7QUFFdEcsTUFBTSxVQUFVLFlBQVksQ0FBQyxJQUFTO0lBQ2xDLHNIQUFzSDtJQUNsSCwyRUFBMkU7SUFDM0UsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUM3QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzNCLE1BQU0sSUFBSSxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDeEIsTUFBTSxJQUFJLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUV2QixNQUFNLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuQyxtRUFBbUU7SUFDbkUsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBRWpCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDN0IsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5Qyw0REFBNEQ7S0FDL0Q7SUFDRCxhQUFhO0lBQ2IsU0FBUyxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDdkIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVELHdDQUF3QztJQUN4QyxhQUFhO0lBQ2IsUUFBUSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFB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QUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFDbkYsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUE7Z0JBQ25CLE1BQUs7YUFDUjtTQUNKO0tBQ0o7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNwQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWxhaW5icnlkZW4vYml0YnVybmVyLXNjcmlwdHMvYmxvYi9tYWluL1Rhc2tzL2NvbnRyYWN0b3IuanMuc29sdmVyLmpzXG5cbmV4cG9ydCBmdW5jdGlvbiBTaG9ydGVzdFBhdGgoZGF0YTogYW55KSB7XG4gICAgLy9zbGlnaHRseSBhZGFwdGVkIGFuZCBzaW1wbGlmaWVkIHRvIGdldCByaWQgb2YgTWluSGVhcCB1c2FnZSwgYW5kIGNvbnN0cnVjdCBhIHZhbGlkIHBhdGggZnJvbSBwb3RlbnRpYWwgY2FuZGlkYXRlcyAgIFxuICAgICAgICAvL01pbkhlYXAgcmVwbGFjZWQgYnkgc2ltcGxlIGFycmF5IGFjdGluZyBhcyBxdWV1ZSAoYnJlYWR0aCBmaXJzdCBzZWFyY2gpICBcbiAgICAgICAgY29uc3Qgd2lkdGggPSBkYXRhWzBdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRzdFkgPSBoZWlnaHQgLSAxO1xuICAgICAgICBjb25zdCBkc3RYID0gd2lkdGggLSAxO1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgICAgIC8vY29uc3QgcHJldjogW1tudW1iZXIsIG51bWJlcl0gfCB1bmRlZmluZWRdW10gPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcXVldWUgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBkaXN0YW5jZVt5XSA9IG5ldyBBcnJheSh3aWR0aCkuZmlsbChJbmZpbml0eSk7XG4gICAgICAgICAgICAvL3ByZXZbeV0gPSBuZXcgQXJyYXkod2lkdGgpLmZpbGwodW5kZWZpbmVkKSBhcyBbdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkUG9zaXRpb24oeSwgeCkge1xuICAgICAgICAgICAgcmV0dXJuIHkgPj0gMCAmJiB5IDwgaGVpZ2h0ICYmIHggPj0gMCAmJiB4IDwgd2lkdGggJiYgZGF0YVt5XVt4XSA9PSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGlzdCBpbi1ib3VuZHMgYW5kIHBhc3NhYmxlIG5laWdoYm9yc1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGZ1bmN0aW9uKiBuZWlnaGJvcnMoeSwgeCkge1xuICAgICAgICAgICAgaWYgKHZhbGlkUG9zaXRpb24oeSAtIDEsIHgpKSB5aWVsZCBbeSAtIDEsIHhdOyAvLyBVcFxuICAgICAgICAgICAgaWYgKHZhbGlkUG9zaXRpb24oeSArIDEsIHgpKSB5aWVsZCBbeSArIDEsIHhdOyAvLyBEb3duXG4gICAgICAgICAgICBpZiAodmFsaWRQb3NpdGlvbih5LCB4IC0gMSkpIHlpZWxkIFt5LCB4IC0gMV07IC8vIExlZnRcbiAgICAgICAgICAgIGlmICh2YWxpZFBvc2l0aW9uKHksIHggKyAxKSkgeWllbGQgW3ksIHggKyAxXTsgLy8gUmlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBhcmUgc3RhcnRpbmcgcG9pbnRcbiAgICAgICAgZGlzdGFuY2VbMF1bMF0gPSAwO1xuXG4gICAgICAgIC8vIyMgT3JpZ2luYWwgdmVyc2lvblxuICAgICAgICAvLyBxdWV1ZS5wdXNoKFswLCAwXSwgMCk7XG4gICAgICAgIC8vIC8vIFRha2UgbmV4dC1uZWFyZXN0IHBvc2l0aW9uIGFuZCBleHBhbmQgcG90ZW50aWFsIHBhdGhzIGZyb20gdGhlcmVcbiAgICAgICAgLy8gd2hpbGUgKHF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIC8vICAgY29uc3QgW3ksIHhdID0gcXVldWUucG9wKCkgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgLy8gICBmb3IgKGNvbnN0IFt5TiwgeE5dIG9mIG5laWdoYm9ycyh5LCB4KSkge1xuICAgICAgICAvLyAgICAgY29uc3QgZCA9IGRpc3RhbmNlW3ldW3hdICsgMTtcbiAgICAgICAgLy8gICAgIGlmIChkIDwgZGlzdGFuY2VbeU5dW3hOXSkge1xuICAgICAgICAvLyAgICAgICBpZiAoZGlzdGFuY2VbeU5dW3hOXSA9PSBJbmZpbml0eSlcbiAgICAgICAgLy8gICAgICAgICAvLyBOb3QgcmVhY2hlZCBwcmV2aW91c2x5XG4gICAgICAgIC8vICAgICAgICAgcXVldWUucHVzaChbeU4sIHhOXSwgZCk7XG4gICAgICAgIC8vICAgICAgIC8vIEZvdW5kIGEgc2hvcnRlciBwYXRoXG4gICAgICAgIC8vICAgICAgIGVsc2UgcXVldWUuY2hhbmdlV2VpZ2h0KChbeVEsIHhRXSkgPT4geVEgPT0geU4gJiYgeFEgPT0geE4sIGQpO1xuICAgICAgICAvLyAgICAgICAvL3ByZXZbeU5dW3hOXSA9IFt5LCB4XTtcbiAgICAgICAgLy8gICAgICAgZGlzdGFuY2VbeU5dW3hOXSA9IGQ7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy9TaW1wbGlmaWVkIHZlcnNpb24uIGQgPCBkaXN0YW5jZVt5Tl1beE5dIHNob3VsZCBuZXZlciBoYXBwZW4gZm9yIEJGUyBpZiBkICE9IGluZmluaXR5LCBzbyB3ZSBza2lwIGNoYW5nZXdlaWdodCBhbmQgc2ltcGxpZnkgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy9hbGdvIGFsd2F5cyBleHBhbmRzIHNob3J0ZXN0IHBhdGgsIGRpc3RhbmNlICE9IGluZmluaXR5IG1lYW5zIGEgPD0gbGVuZ2h0IHBhdGggcmVhY2hlcyBpdCwgb25seSByZW1haW5pbmcgY2FzZSB0byBzb2x2ZSBpcyBpbmZpbml0eSAgICBcbiAgICAgICAgcXVldWUucHVzaChbMCwgMF0pO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgW3ksIHhdID0gcXVldWUuc2hpZnQoKVxuICAgICAgICAgICAgZm9yIChjb25zdCBbeU4sIHhOXSBvZiBuZWlnaGJvcnMoeSwgeCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VbeU5dW3hOXSA9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFt5TiwgeE5dKVxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVt5Tl1beE5dID0gZGlzdGFuY2VbeV1beF0gKyAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gcGF0aCBhdCBhbGw/XG4gICAgICAgIGlmIChkaXN0YW5jZVtkc3RZXVtkc3RYXSA9PSBJbmZpbml0eSkgcmV0dXJuIFwiXCI7XG5cbiAgICAgICAgLy90cmFjZSBhIHBhdGggYmFjayB0byBzdGFydFxuICAgICAgICBsZXQgcGF0aCA9IFwiXCJcbiAgICAgICAgbGV0IFt5QywgeENdID0gW2RzdFksIGRzdFhdXG4gICAgICAgIHdoaWxlICh4QyAhPSAwIHx8IHlDICE9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBkaXN0YW5jZVt5Q11beENdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbeUYsIHhGXSBvZiBuZWlnaGJvcnMoeUMsIHhDKSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVt5Rl1beEZdID09IGRpc3QgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSAoeEMgPT0geEYgPyAoeUMgPT0geUYgKyAxID8gXCJEXCIgOiBcIlVcIikgOiAoeEMgPT0geEYgKyAxID8gXCJSXCIgOiBcIkxcIikpICsgcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgW3lDLCB4Q10gPSBbeUYsIHhGXVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xufSJdfQ==