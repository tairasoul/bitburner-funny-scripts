// taken from https://github.com/alainbryden/bitburner-scripts/blob/main/Tasks/contractor.js.solver.js
export function HammingCodes_to_encoded(value) {
    // Calculates the needed amount of parityBits 'without' the "overall"-Parity
    // @ts-ignore
    const HammingSumOfParity = lengthOfDBits => lengthOfDBits == 0 ? 0 : lengthOfDBits < 3 ? lengthOfDBits + 1 :
        Math.ceil(Math.log2(lengthOfDBits * 2)) <= Math.ceil(Math.log2(1 + lengthOfDBits + Math.ceil(Math.log2(lengthOfDBits)))) ?
            Math.ceil(Math.log2(lengthOfDBits) + 1) : Math.ceil(Math.log2(lengthOfDBits));
    // @ts-ignore
    const data = value.toString(2).split(""); // first, change into binary string, then create array with 1 bit per index
    const sumParity = HammingSumOfParity(data.length); // get the sum of needed parity bits (for later use in encoding)
    // @ts-ignore
    const count = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);
    // function count for specific entries in the array, for later use
    const build = ["x", "x", ...data.splice(0, 1)]; // init the "pre-build"
    for (let i = 2; i < sumParity; i++)
        build.push("x", ...data.splice(0, Math.pow(2, i) - 1)); // add new paritybits and the corresponding data bits (pre-building array)
    // Get the index numbers where the parity bits "x" are placed
    const parityBits = build.map((e, i) => [e, i]).filter(([e, _]) => e == "x").map(([_, i]) => i);
    for (const index of parityBits) {
        const tempcount = index + 1; // set the "stepsize" for the parityBit
        const temparray = []; // temporary array to store the extracted bits
        const tempdata = [...build]; // only work with a copy of the build
        while (tempdata[index] !== undefined) {
            // as long as there are bits on the starting index, do "cut"
            const temp = tempdata.splice(index, tempcount * 2); // cut stepsize*2 bits, then...
            // @ts-ignore
            temparray.push(...temp.splice(0, tempcount)); // ... cut the result again and keep the first half
        }
        temparray.splice(0, 1); // remove first bit, which is the parity one
        build[index] = (count(temparray, "1") % 2).toString(); // count with remainder of 2 and"toString" to store the parityBit
    } // parity done, now the "overall"-parity is set
    build.unshift((count(build, "1") % 2).toString()); // has to be done as last element
    return build.join(""); // return the build as string
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFtbWluZ2NvZGVzLWludC10by1lbmNvZGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NjdC9oYW1taW5nY29kZXMtaW50LXRvLWVuY29kZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsc0dBQXNHO0FBRXRHLE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxLQUFVO0lBQzlDLDRFQUE0RTtJQUM1RSxhQUFhO0lBQ2IsTUFBTSxrQkFBa0IsR0FBRyxhQUFhLENBQUMsRUFBRSxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3hHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLGFBQWEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0SCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBQ3RGLGFBQWE7SUFDYixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLDJFQUEyRTtJQUNySCxNQUFNLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxnRUFBZ0U7SUFDbkgsYUFBYTtJQUNiLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDN0Usa0VBQWtFO0lBQ2xFLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyx1QkFBdUI7SUFDdkUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxDQUFDLEVBQUU7UUFDOUIsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsMEVBQTBFO0lBQ3RJLDZEQUE2RDtJQUM3RCxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvRixLQUFLLE1BQU0sS0FBSyxJQUFJLFVBQVUsRUFBRTtRQUM1QixNQUFNLFNBQVMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsdUNBQXVDO1FBQ3BFLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQyxDQUFDLDhDQUE4QztRQUNwRSxNQUFNLFFBQVEsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxxQ0FBcUM7UUFDbEUsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssU0FBUyxFQUFFO1lBQ2xDLDREQUE0RDtZQUM1RCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQywrQkFBK0I7WUFDbkYsYUFBYTtZQUNiLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsbURBQW1EO1NBQ3BHO1FBQ0QsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyw0Q0FBNEM7UUFDcEUsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLGlFQUFpRTtLQUMzSCxDQUFDLCtDQUErQztJQUNqRCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsaUNBQWlDO0lBQ3BGLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLDZCQUE2QjtBQUN4RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWxhaW5icnlkZW4vYml0YnVybmVyLXNjcmlwdHMvYmxvYi9tYWluL1Rhc2tzL2NvbnRyYWN0b3IuanMuc29sdmVyLmpzXG5cbmV4cG9ydCBmdW5jdGlvbiBIYW1taW5nQ29kZXNfdG9fZW5jb2RlZCh2YWx1ZTogYW55KSB7XG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgbmVlZGVkIGFtb3VudCBvZiBwYXJpdHlCaXRzICd3aXRob3V0JyB0aGUgXCJvdmVyYWxsXCItUGFyaXR5XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IEhhbW1pbmdTdW1PZlBhcml0eSA9IGxlbmd0aE9mREJpdHMgPT4gbGVuZ3RoT2ZEQml0cyA9PSAwID8gMCA6IGxlbmd0aE9mREJpdHMgPCAzID8gbGVuZ3RoT2ZEQml0cyArIDEgOlxuICAgICAgICBNYXRoLmNlaWwoTWF0aC5sb2cyKGxlbmd0aE9mREJpdHMgKiAyKSkgPD0gTWF0aC5jZWlsKE1hdGgubG9nMigxICsgbGVuZ3RoT2ZEQml0cyArIE1hdGguY2VpbChNYXRoLmxvZzIobGVuZ3RoT2ZEQml0cykpKSkgP1xuICAgICAgICAgICAgTWF0aC5jZWlsKE1hdGgubG9nMihsZW5ndGhPZkRCaXRzKSArIDEpIDogTWF0aC5jZWlsKE1hdGgubG9nMihsZW5ndGhPZkRCaXRzKSk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS50b1N0cmluZygyKS5zcGxpdChcIlwiKTsgLy8gZmlyc3QsIGNoYW5nZSBpbnRvIGJpbmFyeSBzdHJpbmcsIHRoZW4gY3JlYXRlIGFycmF5IHdpdGggMSBiaXQgcGVyIGluZGV4XG4gICAgY29uc3Qgc3VtUGFyaXR5ID0gSGFtbWluZ1N1bU9mUGFyaXR5KGRhdGEubGVuZ3RoKTsgLy8gZ2V0IHRoZSBzdW0gb2YgbmVlZGVkIHBhcml0eSBiaXRzIChmb3IgbGF0ZXIgdXNlIGluIGVuY29kaW5nKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBjb3VudCA9IChhcnIsIHZhbCkgPT4gYXJyLnJlZHVjZSgoYSwgdikgPT4gKHYgPT09IHZhbCA/IGEgKyAxIDogYSksIDApO1xuICAgIC8vIGZ1bmN0aW9uIGNvdW50IGZvciBzcGVjaWZpYyBlbnRyaWVzIGluIHRoZSBhcnJheSwgZm9yIGxhdGVyIHVzZVxuICAgIGNvbnN0IGJ1aWxkID0gW1wieFwiLCBcInhcIiwgLi4uZGF0YS5zcGxpY2UoMCwgMSldOyAvLyBpbml0IHRoZSBcInByZS1idWlsZFwiXG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBzdW1QYXJpdHk7IGkrKylcbiAgICAgICAgYnVpbGQucHVzaChcInhcIiwgLi4uZGF0YS5zcGxpY2UoMCwgTWF0aC5wb3coMiwgaSkgLSAxKSk7IC8vIGFkZCBuZXcgcGFyaXR5Yml0cyBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSBiaXRzIChwcmUtYnVpbGRpbmcgYXJyYXkpXG4gICAgLy8gR2V0IHRoZSBpbmRleCBudW1iZXJzIHdoZXJlIHRoZSBwYXJpdHkgYml0cyBcInhcIiBhcmUgcGxhY2VkXG4gICAgY29uc3QgcGFyaXR5Qml0cyA9IGJ1aWxkLm1hcCgoZSwgaSkgPT4gW2UsIGldKS5maWx0ZXIoKFtlLCBfXSkgPT4gZSA9PSBcInhcIikubWFwKChbXywgaV0pID0+IGkpO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgcGFyaXR5Qml0cykge1xuICAgICAgICBjb25zdCB0ZW1wY291bnQgPSBpbmRleCArIDE7IC8vIHNldCB0aGUgXCJzdGVwc2l6ZVwiIGZvciB0aGUgcGFyaXR5Qml0XG4gICAgICAgIGNvbnN0IHRlbXBhcnJheSA9IFtdOyAvLyB0ZW1wb3JhcnkgYXJyYXkgdG8gc3RvcmUgdGhlIGV4dHJhY3RlZCBiaXRzXG4gICAgICAgIGNvbnN0IHRlbXBkYXRhID0gWy4uLmJ1aWxkXTsgLy8gb25seSB3b3JrIHdpdGggYSBjb3B5IG9mIHRoZSBidWlsZFxuICAgICAgICB3aGlsZSAodGVtcGRhdGFbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGFzIGxvbmcgYXMgdGhlcmUgYXJlIGJpdHMgb24gdGhlIHN0YXJ0aW5nIGluZGV4LCBkbyBcImN1dFwiXG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gdGVtcGRhdGEuc3BsaWNlKGluZGV4LCB0ZW1wY291bnQgKiAyKTsgLy8gY3V0IHN0ZXBzaXplKjIgYml0cywgdGhlbi4uLlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGVtcGFycmF5LnB1c2goLi4udGVtcC5zcGxpY2UoMCwgdGVtcGNvdW50KSk7IC8vIC4uLiBjdXQgdGhlIHJlc3VsdCBhZ2FpbiBhbmQga2VlcCB0aGUgZmlyc3QgaGFsZlxuICAgICAgICB9XG4gICAgICAgIHRlbXBhcnJheS5zcGxpY2UoMCwgMSk7IC8vIHJlbW92ZSBmaXJzdCBiaXQsIHdoaWNoIGlzIHRoZSBwYXJpdHkgb25lXG4gICAgICAgIGJ1aWxkW2luZGV4XSA9IChjb3VudCh0ZW1wYXJyYXksIFwiMVwiKSAlIDIpLnRvU3RyaW5nKCk7IC8vIGNvdW50IHdpdGggcmVtYWluZGVyIG9mIDIgYW5kXCJ0b1N0cmluZ1wiIHRvIHN0b3JlIHRoZSBwYXJpdHlCaXRcbiAgICB9IC8vIHBhcml0eSBkb25lLCBub3cgdGhlIFwib3ZlcmFsbFwiLXBhcml0eSBpcyBzZXRcbiAgICBidWlsZC51bnNoaWZ0KChjb3VudChidWlsZCwgXCIxXCIpICUgMikudG9TdHJpbmcoKSk7IC8vIGhhcyB0byBiZSBkb25lIGFzIGxhc3QgZWxlbWVudFxuICAgIHJldHVybiBidWlsZC5qb2luKFwiXCIpOyAvLyByZXR1cm4gdGhlIGJ1aWxkIGFzIHN0cmluZ1xufSJdfQ==