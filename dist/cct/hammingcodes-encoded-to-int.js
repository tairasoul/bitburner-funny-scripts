// taken from https://github.com/alainbryden/bitburner-scripts/blob/main/Tasks/contractor.js.solver.js
export function HammingCodes_to_int(data) {
    //check for altered bit and decode
    const build = data.split(""); // ye, an array for working, again
    const testArray = []; //for the "truthtable". if any is false, the data has an altered bit, will check for and fix it
    const sumParity = Math.ceil(Math.log2(data.length)); // sum of parity for later use
    // @ts-ignore
    const count = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);
    // the count.... again ;)
    let overallParity = build.splice(0, 1).join(""); // store first index, for checking in next step and fix the build properly later on
    testArray.push(overallParity == (count(build, "1") % 2).toString() ? true : false); // first check with the overall parity bit
    for (let i = 0; i < sumParity; i++) {
        // for the rest of the remaining parity bits we also "check"
        const tempIndex = Math.pow(2, i) - 1; // get the parityBits Index
        const tempStep = tempIndex + 1; // set the stepsize
        const tempData = [...build]; // get a "copy" of the build-data for working
        const tempArray = []; // init empty array for "testing"
        while (tempData[tempIndex] != undefined) {
            // extract from the copied data until the "starting" index is undefined
            const temp = [...tempData.splice(tempIndex, tempStep * 2)]; // extract 2*stepsize
            tempArray.push(...temp.splice(0, tempStep)); // and cut again for keeping first half
        }
        const tempParity = tempArray.shift(); // and again save the first index separated for checking with the rest of the data
        testArray.push(tempParity == (count(tempArray, "1") % 2).toString() ? true : false);
        // is the tempParity the calculated data? push answer into the 'truthtable'
    }
    let fixIndex = 0; // init the "fixing" index and start with 0
    for (let i = 1; i < sumParity + 1; i++) {
        // simple binary adding for every boolean in the testArray, starting from 2nd index of it
        fixIndex += testArray[i] ? 0 : Math.pow(2, i) / 2;
    }
    build.unshift(overallParity); // now we need the "overall" parity back in it's place
    // try fix the actual encoded binary string if there is an error
    if (fixIndex > 0 && testArray[0] == false) { // if the overall is false and the sum of calculated values is greater equal 0, fix the corresponding hamming-bit           
        build[fixIndex] = build[fixIndex] == "0" ? "1" : "0";
    }
    else if (testArray[0] == false) { // otherwise, if the the overallparity is the only wrong, fix that one           
        overallParity = overallParity == "0" ? "1" : "0";
    }
    else if (testArray[0] == true && testArray.some((truth) => truth == false)) {
        return 0; // ERROR: There's some strange going on... 2 bits are altered? How? This should not happen
    }
    // oof.. halfway through... we fixed an possible altered bit, now "extract" the parity-bits from the build
    for (let i = sumParity; i >= 0; i--) {
        // start from the last parity down the 2nd index one
        build.splice(Math.pow(2, i), 1);
    }
    build.splice(0, 1); // remove the overall parity bit and we have our binary value
    return parseInt(build.join(""), 2); // parse the integer with redux 2 and we're done!
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFtbWluZ2NvZGVzLWVuY29kZWQtdG8taW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NjdC9oYW1taW5nY29kZXMtZW5jb2RlZC10by1pbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsc0dBQXNHO0FBRXRHLE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxJQUFTO0lBRXJDLGtDQUFrQztJQUNsQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsa0NBQWtDO0lBQ2hFLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQyxDQUFDLCtGQUErRjtJQUNySCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyw4QkFBOEI7SUFDbkYsYUFBYTtJQUNiLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDN0UseUJBQXlCO0lBQ3pCLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLG1GQUFtRjtJQUNwSSxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFD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Q0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDbkM7SUFDRCxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLDZEQUE2RDtJQUNqRixPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsaURBQWlEO0FBQzdGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGFpbmJyeWRlbi9iaXRidXJuZXItc2NyaXB0cy9ibG9iL21haW4vVGFza3MvY29udHJhY3Rvci5qcy5zb2x2ZXIuanNcblxuZXhwb3J0IGZ1bmN0aW9uIEhhbW1pbmdDb2Rlc190b19pbnQoZGF0YTogYW55KSB7XG5cbiAgICAgICAgLy9jaGVjayBmb3IgYWx0ZXJlZCBiaXQgYW5kIGRlY29kZVxuICAgICAgICBjb25zdCBidWlsZCA9IGRhdGEuc3BsaXQoXCJcIik7IC8vIHllLCBhbiBhcnJheSBmb3Igd29ya2luZywgYWdhaW5cbiAgICAgICAgY29uc3QgdGVzdEFycmF5ID0gW107IC8vZm9yIHRoZSBcInRydXRodGFibGVcIi4gaWYgYW55IGlzIGZhbHNlLCB0aGUgZGF0YSBoYXMgYW4gYWx0ZXJlZCBiaXQsIHdpbGwgY2hlY2sgZm9yIGFuZCBmaXggaXRcbiAgICAgICAgY29uc3Qgc3VtUGFyaXR5ID0gTWF0aC5jZWlsKE1hdGgubG9nMihkYXRhLmxlbmd0aCkpOyAvLyBzdW0gb2YgcGFyaXR5IGZvciBsYXRlciB1c2VcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBjb3VudCA9IChhcnIsIHZhbCkgPT4gYXJyLnJlZHVjZSgoYSwgdikgPT4gKHYgPT09IHZhbCA/IGEgKyAxIDogYSksIDApO1xuICAgICAgICAvLyB0aGUgY291bnQuLi4uIGFnYWluIDspXG4gICAgICAgIGxldCBvdmVyYWxsUGFyaXR5ID0gYnVpbGQuc3BsaWNlKDAsIDEpLmpvaW4oXCJcIik7IC8vIHN0b3JlIGZpcnN0IGluZGV4LCBmb3IgY2hlY2tpbmcgaW4gbmV4dCBzdGVwIGFuZCBmaXggdGhlIGJ1aWxkIHByb3Blcmx5IGxhdGVyIG9uXG4gICAgICAgIHRlc3RBcnJheS5wdXNoKG92ZXJhbGxQYXJpdHkgPT0gKGNvdW50KGJ1aWxkLCBcIjFcIikgJSAyKS50b1N0cmluZygpID8gdHJ1ZSA6IGZhbHNlKTsgLy8gZmlyc3QgY2hlY2sgd2l0aCB0aGUgb3ZlcmFsbCBwYXJpdHkgYml0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VtUGFyaXR5OyBpKyspIHtcbiAgICAgICAgICAgIC8vIGZvciB0aGUgcmVzdCBvZiB0aGUgcmVtYWluaW5nIHBhcml0eSBiaXRzIHdlIGFsc28gXCJjaGVja1wiXG4gICAgICAgICAgICBjb25zdCB0ZW1wSW5kZXggPSBNYXRoLnBvdygyLCBpKSAtIDE7IC8vIGdldCB0aGUgcGFyaXR5Qml0cyBJbmRleFxuICAgICAgICAgICAgY29uc3QgdGVtcFN0ZXAgPSB0ZW1wSW5kZXggKyAxOyAvLyBzZXQgdGhlIHN0ZXBzaXplXG4gICAgICAgICAgICBjb25zdCB0ZW1wRGF0YSA9IFsuLi5idWlsZF07IC8vIGdldCBhIFwiY29weVwiIG9mIHRoZSBidWlsZC1kYXRhIGZvciB3b3JraW5nXG4gICAgICAgICAgICBjb25zdCB0ZW1wQXJyYXkgPSBbXTsgLy8gaW5pdCBlbXB0eSBhcnJheSBmb3IgXCJ0ZXN0aW5nXCJcbiAgICAgICAgICAgIHdoaWxlICh0ZW1wRGF0YVt0ZW1wSW5kZXhdICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGV4dHJhY3QgZnJvbSB0aGUgY29waWVkIGRhdGEgdW50aWwgdGhlIFwic3RhcnRpbmdcIiBpbmRleCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gWy4uLnRlbXBEYXRhLnNwbGljZSh0ZW1wSW5kZXgsIHRlbXBTdGVwICogMildOyAvLyBleHRyYWN0IDIqc3RlcHNpemVcbiAgICAgICAgICAgICAgICB0ZW1wQXJyYXkucHVzaCguLi50ZW1wLnNwbGljZSgwLCB0ZW1wU3RlcCkpOyAvLyBhbmQgY3V0IGFnYWluIGZvciBrZWVwaW5nIGZpcnN0IGhhbGZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlbXBQYXJpdHkgPSB0ZW1wQXJyYXkuc2hpZnQoKTsgLy8gYW5kIGFnYWluIHNhdmUgdGhlIGZpcnN0IGluZGV4IHNlcGFyYXRlZCBmb3IgY2hlY2tpbmcgd2l0aCB0aGUgcmVzdCBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgdGVzdEFycmF5LnB1c2godGVtcFBhcml0eSA9PSAoY291bnQodGVtcEFycmF5LCBcIjFcIikgJSAyKS50b1N0cmluZygpID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgICAgIC8vIGlzIHRoZSB0ZW1wUGFyaXR5IHRoZSBjYWxjdWxhdGVkIGRhdGE/IHB1c2ggYW5zd2VyIGludG8gdGhlICd0cnV0aHRhYmxlJ1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaXhJbmRleCA9IDA7IC8vIGluaXQgdGhlIFwiZml4aW5nXCIgaW5kZXggYW5kIHN0YXJ0IHdpdGggMFxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN1bVBhcml0eSArIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gc2ltcGxlIGJpbmFyeSBhZGRpbmcgZm9yIGV2ZXJ5IGJvb2xlYW4gaW4gdGhlIHRlc3RBcnJheSwgc3RhcnRpbmcgZnJvbSAybmQgaW5kZXggb2YgaXRcbiAgICAgICAgICAgIGZpeEluZGV4ICs9IHRlc3RBcnJheVtpXSA/IDAgOiBNYXRoLnBvdygyLCBpKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGQudW5zaGlmdChvdmVyYWxsUGFyaXR5KTsgLy8gbm93IHdlIG5lZWQgdGhlIFwib3ZlcmFsbFwiIHBhcml0eSBiYWNrIGluIGl0J3MgcGxhY2VcbiAgICAgICAgLy8gdHJ5IGZpeCB0aGUgYWN0dWFsIGVuY29kZWQgYmluYXJ5IHN0cmluZyBpZiB0aGVyZSBpcyBhbiBlcnJvclxuICAgICAgICBpZiAoZml4SW5kZXggPiAwICYmIHRlc3RBcnJheVswXSA9PSBmYWxzZSkgeyAvLyBpZiB0aGUgb3ZlcmFsbCBpcyBmYWxzZSBhbmQgdGhlIHN1bSBvZiBjYWxjdWxhdGVkIHZhbHVlcyBpcyBncmVhdGVyIGVxdWFsIDAsIGZpeCB0aGUgY29ycmVzcG9uZGluZyBoYW1taW5nLWJpdCAgICAgICAgICAgXG4gICAgICAgICAgICBidWlsZFtmaXhJbmRleF0gPSBidWlsZFtmaXhJbmRleF0gPT0gXCIwXCIgPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRlc3RBcnJheVswXSA9PSBmYWxzZSkgeyAvLyBvdGhlcndpc2UsIGlmIHRoZSB0aGUgb3ZlcmFsbHBhcml0eSBpcyB0aGUgb25seSB3cm9uZywgZml4IHRoYXQgb25lICAgICAgICAgICBcbiAgICAgICAgICAgIG92ZXJhbGxQYXJpdHkgPSBvdmVyYWxsUGFyaXR5ID09IFwiMFwiID8gXCIxXCIgOiBcIjBcIjtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0QXJyYXlbMF0gPT0gdHJ1ZSAmJiB0ZXN0QXJyYXkuc29tZSgodHJ1dGgpID0+IHRydXRoID09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIEVSUk9SOiBUaGVyZSdzIHNvbWUgc3RyYW5nZSBnb2luZyBvbi4uLiAyIGJpdHMgYXJlIGFsdGVyZWQ/IEhvdz8gVGhpcyBzaG91bGQgbm90IGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIC8vIG9vZi4uIGhhbGZ3YXkgdGhyb3VnaC4uLiB3ZSBmaXhlZCBhbiBwb3NzaWJsZSBhbHRlcmVkIGJpdCwgbm93IFwiZXh0cmFjdFwiIHRoZSBwYXJpdHktYml0cyBmcm9tIHRoZSBidWlsZFxuICAgICAgICBmb3IgKGxldCBpID0gc3VtUGFyaXR5OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLy8gc3RhcnQgZnJvbSB0aGUgbGFzdCBwYXJpdHkgZG93biB0aGUgMm5kIGluZGV4IG9uZVxuICAgICAgICAgICAgYnVpbGQuc3BsaWNlKE1hdGgucG93KDIsIGkpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZC5zcGxpY2UoMCwgMSk7IC8vIHJlbW92ZSB0aGUgb3ZlcmFsbCBwYXJpdHkgYml0IGFuZCB3ZSBoYXZlIG91ciBiaW5hcnkgdmFsdWVcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGJ1aWxkLmpvaW4oXCJcIiksIDIpOyAvLyBwYXJzZSB0aGUgaW50ZWdlciB3aXRoIHJlZHV4IDIgYW5kIHdlJ3JlIGRvbmUhXG59Il19