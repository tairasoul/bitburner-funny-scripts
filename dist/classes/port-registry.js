import Multiport from "/classes/multiport";
// Classes
class MessageQueue {
    port;
    constructor(ns, start, end) {
        this.port = new Multiport(ns, start, end);
    }
    get requestAvailable() {
        return this.port.peek() != null;
    }
    async processRequest(reqProcessor) {
        const data = this.port.read();
        const parsed = JSON.parse(data);
        await reqProcessor(parsed);
    }
}
class PortHandler {
    ns;
    requests;
    responses;
    assigned = [];
    constructor(ns) {
        this.ns = ns;
        this.requests = new MessageQueue(ns, 1, 100);
        this.responses = new Multiport(ns, 101, 10000);
    }
    async startHandling() {
        while (true) {
            await this.ns.sleep(1);
            if (this.requests.requestAvailable) {
                await this.requests.processRequest(async (message) => await this.handleRequest(message));
            }
        }
    }
    async handleRequest(message) {
        switch (message.request) {
            case "assign":
                if (this.arePortsUnassigned(message.ports)) {
                    this.assigned.push({
                        pid: message.pid,
                        ports: message.ports
                    });
                    this.sendResponse({
                        pid: message.pid,
                        result: "assigned"
                    });
                }
                else {
                    const owners = [];
                    for (const port of message.ports) {
                        const owner = this.getOwnerOf(port);
                        if (owner) {
                            owners.push(owner);
                        }
                    }
                    this.sendResponse({
                        pid: message.pid,
                        result: "couldnt assign",
                        owned_by: owners
                    });
                }
                break;
            case "unassign":
                const found = this.assigned.find((v) => {
                    let portsMatch = true;
                    message.ports.forEach((val) => {
                        if (!v.ports.includes(val)) {
                            portsMatch = false;
                        }
                    });
                    return portsMatch;
                });
                if (found) {
                    this.assigned = this.assigned.filter((v) => v != found);
                }
                break;
            case "assignAvailable":
                const availablePorts = [];
                let availableFound = 0;
                for (let i = 10001; i < 200000; i++) {
                    if (this.isPortUnassigned(i)) {
                        availablePorts.push(i);
                        availableFound++;
                    }
                    if (availableFound >= message.portAmount)
                        break;
                }
                this.assigned.push({
                    pid: message.pid,
                    ports: availablePorts
                });
                this.sendResponse({
                    result: "assignedAvailable",
                    pid: message.pid,
                    assignedPorts: availablePorts
                });
        }
    }
    getOwnerOf(port) {
        for (const assigned of this.assigned) {
            if (assigned.ports.includes(port))
                return assigned.pid;
        }
        return;
    }
    isPortUnassigned(port) {
        for (const assigned of this.assigned) {
            if (assigned.ports.includes(port)) {
                return false;
            }
        }
        return true;
    }
    getUnassignedPortsFromList(ports) {
        const unassigned = [];
        for (const port of ports) {
            if (this.isPortUnassigned(port))
                unassigned.push(port);
        }
        return unassigned;
    }
    arePortsUnassigned(ports) {
        for (const port of ports) {
            if (!this.isPortUnassigned(port))
                return false;
        }
        return true;
    }
    sendResponse(response) {
        this.responses.write(JSON.stringify(response), (_, port) => port.empty());
    }
}
// Main code
export async function main(ns) {
    ns.disableLog("ALL");
    const handler = new PortHandler(ns);
    await handler.startHandling();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9ydC1yZWdpc3RyeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGFzc2VzL3BvcnQtcmVnaXN0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxTQUFTLE1BQU0sb0JBQW9CLENBQUM7QUFxQzNDLFVBQVU7QUFFVixNQUFNLFlBQVk7SUFDZCxJQUFJLENBQVk7SUFDaEIsWUFBWSxFQUFTLEVBQUUsS0FBYSxFQUFFLEdBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLFNBQVMsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRCxJQUFJLGdCQUFnQjtRQUNoQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFBO0lBQ25DLENBQUM7SUFFRCxLQUFLLENBQUMsY0FBYyxDQUFDLFlBQXVEO1FBQ3hFLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDOUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQW1CLENBQUM7UUFDbEQsTUFBTSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDL0IsQ0FBQztDQUNKO0FBRUQsTUFBTSxXQUFXO0lBQ0wsRUFBRSxDQUFRO0lBQ1YsUUFBUSxDQUFlO0lBQ3ZCLFNBQVMsQ0FBWTtJQUNyQixRQUFRLEdBQWUsRUFBRSxDQUFDO0lBQ2xDLFlBQVksRUFBUztRQUNqQixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNiLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDbkQs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Z0IsQ0FBQyxJQUFJLENBQUM7Z0JBQzVCLE9BQU8sS0FBSyxDQUFDO1NBQ3BCO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELFlBQVksQ0FBQyxRQUF5QjtRQUNsQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDOUUsQ0FBQztDQUNKO0FBRUQsWUFBWTtBQUVaLE1BQU0sQ0FBQyxLQUFLLFVBQVUsSUFBSSxDQUFDLEVBQVM7SUFDaEMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNwQixNQUFNLE9BQU8sR0FBRyxJQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNwQyxNQUFNLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQztBQUNsQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5zIGZyb20gXCJAbnNcIjtcbmltcG9ydCBNdWx0aXBvcnQgZnJvbSBcIi9jbGFzc2VzL211bHRpcG9ydFwiO1xuXG4vLyBUeXBlc1xuXG50eXBlIEFzc2lnbmVkID0ge1xuICAgIHBpZDogbnVtYmVyO1xuICAgIHBvcnRzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IHR5cGUgUmVzcG9uc2VNZXNzYWdlID0ge1xuICAgIHBpZDogbnVtYmVyO1xuICAgIHJlc3VsdDogXCJhc3NpZ25lZFwiXG59IHwge1xuICAgIHBpZDogbnVtYmVyO1xuICAgIHJlc3VsdDogXCJjb3VsZG50IGFzc2lnblwiO1xuICAgIG93bmVkX2J5OiBudW1iZXJbXTtcbn0gfCB7XG4gICAgcGlkOiBudW1iZXI7XG4gICAgcmVzdWx0OiBcImFzc2lnbmVkQXZhaWxhYmxlXCI7XG4gICAgYXNzaWduZWRQb3J0czogbnVtYmVyW107XG59XG5cblxuZXhwb3J0IHR5cGUgSGFuZGxlck1lc3NhZ2UgPSB7XG4gICAgcmVxdWVzdDogXCJhc3NpZ25cIjtcbiAgICBwb3J0czogbnVtYmVyW107XG4gICAgcGlkOiBudW1iZXI7XG59IHwge1xuICAgIHJlcXVlc3Q6IFwidW5hc3NpZ25cIjtcbiAgICBwb3J0czogbnVtYmVyW107XG4gICAgcGlkOiBudW1iZXI7XG59IHwge1xuICAgIHJlcXVlc3Q6IFwiYXNzaWduQXZhaWxhYmxlXCI7XG4gICAgcG9ydEFtb3VudDogbnVtYmVyO1xuICAgIHBpZDogbnVtYmVyO1xufVxuXG4vLyBDbGFzc2VzXG5cbmNsYXNzIE1lc3NhZ2VRdWV1ZSB7XG4gICAgcG9ydDogTXVsdGlwb3J0O1xuICAgIGNvbnN0cnVjdG9yKG5zOiBucy5OUywgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5wb3J0ID0gbmV3IE11bHRpcG9ydChucywgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgZ2V0IHJlcXVlc3RBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcnQucGVlaygpICE9IG51bGxcbiAgICB9XG5cbiAgICBhc3luYyBwcm9jZXNzUmVxdWVzdChyZXFQcm9jZXNzb3I6IChtZXNzYWdlOiBIYW5kbGVyTWVzc2FnZSkgPT4gUHJvbWlzZTxhbnk+KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnBvcnQucmVhZCgpO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpIGFzIEhhbmRsZXJNZXNzYWdlO1xuICAgICAgICBhd2FpdCByZXFQcm9jZXNzb3IocGFyc2VkKTtcbiAgICB9XG59XG5cbmNsYXNzIFBvcnRIYW5kbGVyIHtcbiAgICBwcml2YXRlIG5zOiBucy5OUztcbiAgICBwcml2YXRlIHJlcXVlc3RzOiBNZXNzYWdlUXVldWU7XG4gICAgcHJpdmF0ZSByZXNwb25zZXM6IE11bHRpcG9ydDtcbiAgICBwcml2YXRlIGFzc2lnbmVkOiBBc3NpZ25lZFtdID0gW107XG4gICAgY29uc3RydWN0b3IobnM6IG5zLk5TKSB7XG4gICAgICAgIHRoaXMubnMgPSBucztcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBNZXNzYWdlUXVldWUobnMsIDEsIDEwMCk7XG4gICAgICAgIHRoaXMucmVzcG9uc2VzID0gbmV3IE11bHRpcG9ydChucywgMTAxLCAxMDAwMCk7XG4gICAgfVxuXG4gICAgYXN5bmMgc3RhcnRIYW5kbGluZygpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubnMuc2xlZXAoMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0cy5yZXF1ZXN0QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0cy5wcm9jZXNzUmVxdWVzdChhc3luYyAobWVzc2FnZSkgPT4gYXdhaXQgdGhpcy5oYW5kbGVSZXF1ZXN0KG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZVJlcXVlc3QobWVzc2FnZTogSGFuZGxlck1lc3NhZ2UpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhc3NpZ25cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcmVQb3J0c1VuYXNzaWduZWQobWVzc2FnZS5wb3J0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25lZC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpZDogbWVzc2FnZS5waWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydHM6IG1lc3NhZ2UucG9ydHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWQ6IG1lc3NhZ2UucGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogXCJhc3NpZ25lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb3J0IG9mIG1lc3NhZ2UucG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gdGhpcy5nZXRPd25lck9mKHBvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJzLnB1c2gob3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpZDogbWVzc2FnZS5waWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBcImNvdWxkbnQgYXNzaWduXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZWRfYnk6IG93bmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVuYXNzaWduXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLmFzc2lnbmVkLmZpbmQoKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcnRzTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBvcnRzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2LnBvcnRzLmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0c01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3J0c01hdGNoO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduZWQgPSB0aGlzLmFzc2lnbmVkLmZpbHRlcigodikgPT4gdiAhPSBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFzc2lnbkF2YWlsYWJsZVwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZVBvcnRzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBhdmFpbGFibGVGb3VuZCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDEwMDAxOyBpIDwgMjAwMDAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQb3J0VW5hc3NpZ25lZChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlUG9ydHMucHVzaChpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlRm91bmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlRm91bmQgPj0gbWVzc2FnZS5wb3J0QW1vdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduZWQucHVzaChcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGlkOiBtZXNzYWdlLnBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRzOiBhdmFpbGFibGVQb3J0c1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IFwiYXNzaWduZWRBdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZDogbWVzc2FnZS5waWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZFBvcnRzOiBhdmFpbGFibGVQb3J0c1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0T3duZXJPZihwb3J0OiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBhc3NpZ25lZCBvZiB0aGlzLmFzc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXNzaWduZWQucG9ydHMuaW5jbHVkZXMocG9ydCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnbmVkLnBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQb3J0VW5hc3NpZ25lZChwb3J0OiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBhc3NpZ25lZCBvZiB0aGlzLmFzc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXNzaWduZWQucG9ydHMuaW5jbHVkZXMocG9ydCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZ2V0VW5hc3NpZ25lZFBvcnRzRnJvbUxpc3QocG9ydHM6IG51bWJlcltdKSB7XG4gICAgICAgIGNvbnN0IHVuYXNzaWduZWQ6IG51bWJlcltdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcG9ydCBvZiBwb3J0cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQb3J0VW5hc3NpZ25lZChwb3J0KSlcbiAgICAgICAgICAgICAgICB1bmFzc2lnbmVkLnB1c2gocG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuYXNzaWduZWQ7XG4gICAgfVxuXG4gICAgYXJlUG9ydHNVbmFzc2lnbmVkKHBvcnRzOiBudW1iZXJbXSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBvcnQgb2YgcG9ydHMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1BvcnRVbmFzc2lnbmVkKHBvcnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZW5kUmVzcG9uc2UocmVzcG9uc2U6IFJlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlcy53cml0ZShKU09OLnN0cmluZ2lmeShyZXNwb25zZSksIChfLCBwb3J0KSA9PiBwb3J0LmVtcHR5KCkpO1xuICAgIH1cbn1cblxuLy8gTWFpbiBjb2RlXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWluKG5zOiBucy5OUykge1xuICAgIG5zLmRpc2FibGVMb2coXCJBTExcIilcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IFBvcnRIYW5kbGVyKG5zKTtcbiAgICBhd2FpdCBoYW5kbGVyLnN0YXJ0SGFuZGxpbmcoKTtcbn0iXX0=