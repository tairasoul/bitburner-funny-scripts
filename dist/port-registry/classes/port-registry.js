import Multiport from "/port-registry/classes/multiport";
// Classes
class MessageQueue {
    port;
    constructor(ns, start, end) {
        this.port = new Multiport(ns, start, end);
    }
    get requestAvailable() {
        return this.port.peek() != null;
    }
    async processRequest(reqProcessor) {
        const data = this.port.read();
        const parsed = JSON.parse(data);
        await reqProcessor(parsed);
    }
}
class PortHandler {
    ns;
    requests;
    responses;
    assigned = [];
    constructor(ns) {
        this.ns = ns;
        this.requests = new MessageQueue(ns, 1, 100);
        this.responses = new Multiport(ns, 101, 10000);
    }
    async startHandling() {
        while (true) {
            await this.ns.sleep(1);
            if (this.requests.requestAvailable) {
                await this.requests.processRequest(async (message) => await this.handleRequest(message));
            }
        }
    }
    async handleRequest(message) {
        switch (message.request) {
            case "assign":
                if (this.arePortsUnassigned(message.ports)) {
                    this.assigned.push({
                        pid: message.pid,
                        ports: message.ports
                    });
                    this.sendResponse({
                        pid: message.pid,
                        result: "assigned"
                    });
                }
                else {
                    const owners = [];
                    for (const port of message.ports) {
                        const owner = this.getOwnerOf(port);
                        if (owner) {
                            owners.push(owner);
                        }
                    }
                    this.sendResponse({
                        pid: message.pid,
                        result: "couldnt assign",
                        owned_by: owners
                    });
                }
                break;
            case "unassign":
                const found = this.assigned.find((v) => {
                    let portsMatch = true;
                    message.ports.forEach((val) => {
                        if (!v.ports.includes(val)) {
                            portsMatch = false;
                        }
                    });
                    return portsMatch;
                });
                if (found) {
                    this.assigned = this.assigned.filter((v) => v != found);
                }
                break;
            case "assignAvailable":
                const availablePorts = [];
                let availableFound = 0;
                for (let i = 10001; i < 200000; i++) {
                    if (this.isPortUnassigned(i)) {
                        availablePorts.push(i);
                        availableFound++;
                    }
                    if (availableFound >= message.portAmount)
                        break;
                }
                this.assigned.push({
                    pid: message.pid,
                    ports: availablePorts
                });
                this.sendResponse({
                    result: "assignedAvailable",
                    pid: message.pid,
                    assignedPorts: availablePorts
                });
        }
    }
    getOwnerOf(port) {
        for (const assigned of this.assigned) {
            if (assigned.ports.includes(port))
                return assigned.pid;
        }
        return;
    }
    isPortUnassigned(port) {
        for (const assigned of this.assigned) {
            if (assigned.ports.includes(port)) {
                return false;
            }
        }
        return true;
    }
    getUnassignedPortsFromList(ports) {
        const unassigned = [];
        for (const port of ports) {
            if (this.isPortUnassigned(port))
                unassigned.push(port);
        }
        return unassigned;
    }
    arePortsUnassigned(ports) {
        for (const port of ports) {
            if (!this.isPortUnassigned(port))
                return false;
        }
        return true;
    }
    sendResponse(response) {
        this.responses.write(JSON.stringify(response), (_, port) => port.empty());
    }
}
// Main code
export async function main(ns) {
    ns.disableLog("ALL");
    const handler = new PortHandler(ns);
    await handler.startHandling();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9ydC1yZWdpc3RyeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3J0LXJlZ2lzdHJ5L2NsYXNzZXMvcG9ydC1yZWdpc3RyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLFNBQVMsTUFBTSxrQ0FBa0MsQ0FBQztBQXFDekQsVUFBVTtBQUVWLE1BQU0sWUFBWTtJQUNkLElBQUksQ0FBWTtJQUNoQixZQUFZLEVBQVMsRUFBRSxLQUFhLEVBQUUsR0FBVztRQUM3QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELElBQUksZ0JBQWdCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUE7SUFDbkMsQ0FBQztJQUVELEtBQUssQ0FBQyxjQUFjLENBQUMsWUFBdUQ7UUFDeEUsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUM5QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBbUIsQ0FBQztRQUNsRCxNQUFNLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQixDQUFDO0NBQ0o7QUFFRCxNQUFNLFdBQVc7SUFDTCxFQUFFLENBQVE7SUFDVixRQUFRLENBQWU7SUFDdkIsU0FBUyxDQUFZO0lBQ3JCLFFBQVEsR0FBZSxFQUFFLENBQUM7SUFDbEMsWUFBWSxFQUFTO1FBQ2pCLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFlBQVksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxTQUFTLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxLQUFL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QUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQztnQkFDNUIsT0FBTyxLQUFLLENBQUM7U0FDcEI7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsWUFBWSxDQUFDLFFBQXlCO1FBQ2xDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUM5RSxDQUFDO0NBQ0o7QUFFRCxZQUFZO0FBRVosTUFBTSxDQUFDLEtBQUssVUFBVSxJQUFJLENBQUMsRUFBUztJQUNoQyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ3BCLE1BQU0sT0FBTyxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3BDLE1BQU0sT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDO0FBQ2xDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbnMgZnJvbSBcIkBuc1wiO1xuaW1wb3J0IE11bHRpcG9ydCBmcm9tIFwiL3BvcnQtcmVnaXN0cnkvY2xhc3Nlcy9tdWx0aXBvcnRcIjtcblxuLy8gVHlwZXNcblxudHlwZSBBc3NpZ25lZCA9IHtcbiAgICBwaWQ6IG51bWJlcjtcbiAgICBwb3J0czogbnVtYmVyW107XG59XG5cbmV4cG9ydCB0eXBlIFJlc3BvbnNlTWVzc2FnZSA9IHtcbiAgICBwaWQ6IG51bWJlcjtcbiAgICByZXN1bHQ6IFwiYXNzaWduZWRcIlxufSB8IHtcbiAgICBwaWQ6IG51bWJlcjtcbiAgICByZXN1bHQ6IFwiY291bGRudCBhc3NpZ25cIjtcbiAgICBvd25lZF9ieTogbnVtYmVyW107XG59IHwge1xuICAgIHBpZDogbnVtYmVyO1xuICAgIHJlc3VsdDogXCJhc3NpZ25lZEF2YWlsYWJsZVwiO1xuICAgIGFzc2lnbmVkUG9ydHM6IG51bWJlcltdO1xufVxuXG5cbmV4cG9ydCB0eXBlIEhhbmRsZXJNZXNzYWdlID0ge1xuICAgIHJlcXVlc3Q6IFwiYXNzaWduXCI7XG4gICAgcG9ydHM6IG51bWJlcltdO1xuICAgIHBpZDogbnVtYmVyO1xufSB8IHtcbiAgICByZXF1ZXN0OiBcInVuYXNzaWduXCI7XG4gICAgcG9ydHM6IG51bWJlcltdO1xuICAgIHBpZDogbnVtYmVyO1xufSB8IHtcbiAgICByZXF1ZXN0OiBcImFzc2lnbkF2YWlsYWJsZVwiO1xuICAgIHBvcnRBbW91bnQ6IG51bWJlcjtcbiAgICBwaWQ6IG51bWJlcjtcbn1cblxuLy8gQ2xhc3Nlc1xuXG5jbGFzcyBNZXNzYWdlUXVldWUge1xuICAgIHBvcnQ6IE11bHRpcG9ydDtcbiAgICBjb25zdHJ1Y3RvcihuczogbnMuTlMsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMucG9ydCA9IG5ldyBNdWx0aXBvcnQobnMsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIGdldCByZXF1ZXN0QXZhaWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3J0LnBlZWsoKSAhPSBudWxsXG4gICAgfVxuXG4gICAgYXN5bmMgcHJvY2Vzc1JlcXVlc3QocmVxUHJvY2Vzc29yOiAobWVzc2FnZTogSGFuZGxlck1lc3NhZ2UpID0+IFByb21pc2U8YW55Pikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5wb3J0LnJlYWQoKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKSBhcyBIYW5kbGVyTWVzc2FnZTtcbiAgICAgICAgYXdhaXQgcmVxUHJvY2Vzc29yKHBhcnNlZCk7XG4gICAgfVxufVxuXG5jbGFzcyBQb3J0SGFuZGxlciB7XG4gICAgcHJpdmF0ZSBuczogbnMuTlM7XG4gICAgcHJpdmF0ZSByZXF1ZXN0czogTWVzc2FnZVF1ZXVlO1xuICAgIHByaXZhdGUgcmVzcG9uc2VzOiBNdWx0aXBvcnQ7XG4gICAgcHJpdmF0ZSBhc3NpZ25lZDogQXNzaWduZWRbXSA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKG5zOiBucy5OUykge1xuICAgICAgICB0aGlzLm5zID0gbnM7XG4gICAgICAgIHRoaXMucmVxdWVzdHMgPSBuZXcgTWVzc2FnZVF1ZXVlKG5zLCAxLCAxMDApO1xuICAgICAgICB0aGlzLnJlc3BvbnNlcyA9IG5ldyBNdWx0aXBvcnQobnMsIDEwMSwgMTAwMDApO1xuICAgIH1cblxuICAgIGFzeW5jIHN0YXJ0SGFuZGxpbmcoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm5zLnNsZWVwKDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdHMucmVxdWVzdEF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVxdWVzdHMucHJvY2Vzc1JlcXVlc3QoYXN5bmMgKG1lc3NhZ2UpID0+IGF3YWl0IHRoaXMuaGFuZGxlUmVxdWVzdChtZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBoYW5kbGVSZXF1ZXN0KG1lc3NhZ2U6IEhhbmRsZXJNZXNzYWdlKSB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5yZXF1ZXN0KSB7XG4gICAgICAgICAgICBjYXNlIFwiYXNzaWduXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJlUG9ydHNVbmFzc2lnbmVkKG1lc3NhZ2UucG9ydHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduZWQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWQ6IG1lc3NhZ2UucGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRzOiBtZXNzYWdlLnBvcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlkOiBtZXNzYWdlLnBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IFwiYXNzaWduZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lcnM6IG51bWJlcltdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9ydCBvZiBtZXNzYWdlLnBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IHRoaXMuZ2V0T3duZXJPZihwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVycy5wdXNoKG93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWQ6IG1lc3NhZ2UucGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogXCJjb3VsZG50IGFzc2lnblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVkX2J5OiBvd25lcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1bmFzc2lnblwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5hc3NpZ25lZC5maW5kKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3J0c01hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb3J0cy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdi5wb3J0cy5pbmNsdWRlcyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydHNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9ydHNNYXRjaDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFzc2lnbmVkID0gdGhpcy5hc3NpZ25lZC5maWx0ZXIoKHYpID0+IHYgIT0gZm91bmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhc3NpZ25BdmFpbGFibGVcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGVQb3J0czogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgYXZhaWxhYmxlRm91bmQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxMDAwMTsgaSA8IDIwMDAwMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUG9ydFVuYXNzaWduZWQoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVBvcnRzLnB1c2goaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUZvdW5kKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YWlsYWJsZUZvdW5kID49IG1lc3NhZ2UucG9ydEFtb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFzc2lnbmVkLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZDogbWVzc2FnZS5waWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0czogYXZhaWxhYmxlUG9ydHNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBcImFzc2lnbmVkQXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWQ6IG1lc3NhZ2UucGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRQb3J0czogYXZhaWxhYmxlUG9ydHNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE93bmVyT2YocG9ydDogbnVtYmVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgYXNzaWduZWQgb2YgdGhpcy5hc3NpZ25lZCkge1xuICAgICAgICAgICAgaWYgKGFzc2lnbmVkLnBvcnRzLmluY2x1ZGVzKHBvcnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ25lZC5waWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUG9ydFVuYXNzaWduZWQocG9ydDogbnVtYmVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgYXNzaWduZWQgb2YgdGhpcy5hc3NpZ25lZCkge1xuICAgICAgICAgICAgaWYgKGFzc2lnbmVkLnBvcnRzLmluY2x1ZGVzKHBvcnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldFVuYXNzaWduZWRQb3J0c0Zyb21MaXN0KHBvcnRzOiBudW1iZXJbXSkge1xuICAgICAgICBjb25zdCB1bmFzc2lnbmVkOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBvcnQgb2YgcG9ydHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUG9ydFVuYXNzaWduZWQocG9ydCkpXG4gICAgICAgICAgICAgICAgdW5hc3NpZ25lZC5wdXNoKHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmFzc2lnbmVkO1xuICAgIH1cblxuICAgIGFyZVBvcnRzVW5hc3NpZ25lZChwb3J0czogbnVtYmVyW10pIHtcbiAgICAgICAgZm9yIChjb25zdCBwb3J0IG9mIHBvcnRzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQb3J0VW5hc3NpZ25lZChwb3J0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc2VuZFJlc3BvbnNlKHJlc3BvbnNlOiBSZXNwb25zZU1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZXMud3JpdGUoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpLCAoXywgcG9ydCkgPT4gcG9ydC5lbXB0eSgpKTtcbiAgICB9XG59XG5cbi8vIE1haW4gY29kZVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFpbihuczogbnMuTlMpIHtcbiAgICBucy5kaXNhYmxlTG9nKFwiQUxMXCIpXG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBQb3J0SGFuZGxlcihucyk7XG4gICAgYXdhaXQgaGFuZGxlci5zdGFydEhhbmRsaW5nKCk7XG59Il19